import 'package:flutter/material.dart';
import 'package:habit_tracker/Helper/auth/firebase_auth/auth_util.dart';
import 'package:habit_tracker/Helper/backend/backend.dart';
import 'package:habit_tracker/Helper/backend/habit_tracking_util.dart';
import 'package:habit_tracker/Helper/backend/schema/category_record.dart';
import 'package:habit_tracker/Helper/backend/schema/activity_record.dart';
import 'package:habit_tracker/Helper/flutter_flow/flutter_flow_util.dart';
import 'package:habit_tracker/Helper/utils/floating_timer.dart';
import 'package:habit_tracker/Helper/utils/flutter_flow_theme.dart';
import 'package:habit_tracker/Helper/utils/item_component.dart';
import 'package:habit_tracker/Helper/utils/notification_center.dart';
import 'package:habit_tracker/Helper/utils/task_type_dropdown_helper.dart';
import 'package:habit_tracker/Helper/utils/frequency_config_dialog.dart';
import 'package:intl/intl.dart';

class TaskPage extends StatefulWidget {
  final String? categoryId;
  final bool showCompleted;

  const TaskPage({super.key, this.categoryId, required this.showCompleted});

  @override
  State<TaskPage> createState() => _TaskPageState();
}

class _TaskPageState extends State<TaskPage> {
  final TextEditingController _quickAddController = TextEditingController();
  List<ActivityRecord> _tasks = [];
  List<ActivityRecord> _habits = [];
  List<CategoryRecord> _categories = [];
  bool _isLoading = true;
  bool _didInitialDependencies = false;
  String sortMode = 'default';
  String? _selectedQuickCategoryId;
  String? _selectedQuickTrackingType = 'binary';
  DateTime? _selectedQuickDueDate;
  int _quickTargetNumber = 1;
  Duration _quickTargetDuration = const Duration(hours: 1);
  String _quickUnit = '';
  final TextEditingController _quickUnitController = TextEditingController();
  late bool _showCompleted;
  bool quickIsRecurring = false;
  FrequencyConfig? _quickFrequencyConfig;
  final Map<String, bool> _sectionExpanded = {
    'Overdue': true,
    'Today': true,
    'Tomorrow': true,
    'This Week': true,
    'Later': true,
    'No due date': true,
  };

  @override
  void initState() {
    super.initState();
    _showCompleted = widget.showCompleted;
    _loadData();
    NotificationCenter.addObserver(this, 'showTaskCompleted', (param) {
      if (param is bool && mounted) {
        setState(() {
          _showCompleted = param;
        });
      }
    });
  }

  @override
  void dispose() {
    NotificationCenter.removeObserver(this);
    _quickAddController.dispose();
    super.dispose();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (_didInitialDependencies) {
      final route = ModalRoute.of(context);
      if (route != null && route.isCurrent) {
        _loadData();
      }
    } else {
      _didInitialDependencies = true;
    }
  }

  @override
  Widget build(BuildContext context) {
    final returnedWidget = _isLoading
        ? const Center(child: CircularProgressIndicator())
        : Stack(
            children: [
              RefreshIndicator(
                onRefresh: _loadData,
                child: CustomScrollView(
                  slivers: [
                    SliverToBoxAdapter(child: _buildQuickAdd()),
                    ..._buildSections(),
                  ],
                ),
              ),
              FloatingTimer(
                activeHabits: _activeFloatingHabits,
                onRefresh: _loadData,
                onHabitUpdated: (updated) => _updateHabitInLocalState(updated),
              ),
            ],
          );
    return returnedWidget;
  }

  List<ActivityRecord> get _activeFloatingHabits {
    final all = [..._tasks, ..._habits];
    return all.where((h) => h.showInFloatingTimer == true).toList();
  }

  Future<void> _loadData() async {
    setState(() => _isLoading = true);
    try {
      final uid = currentUserUid;
      if (uid.isEmpty) {
        setState(() => _isLoading = false);
        return;
      }
      final allHabits = await queryActivitiesRecordOnce(userId: uid);
      final categories = await queryTaskCategoriesOnce(userId: uid);

      setState(() {
        _categories = categories;
        _tasks = allHabits.where((h) {
          if (h.categoryType != 'task') return false;
          return (widget.categoryId == null ||
              h.categoryId == widget.categoryId);
        }).toList();
        _habits = allHabits.where((h) {
          if (h.categoryType != 'habit') return false;
          return (widget.categoryId == null ||
              h.categoryId == widget.categoryId);
        }).toList();
        if (_selectedQuickCategoryId == null && categories.isNotEmpty) {
          _selectedQuickCategoryId = categories.first.reference.id;
        }
        _isLoading = false;
      });
    } catch (e) {
      setState(() => _isLoading = false);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error loading tasks: $e')),
        );
      }
    }
  }

  Widget _buildQuickAdd() {
    final quickAddWidget = Container(
      decoration: BoxDecoration(
        color: FlutterFlowTheme.of(context).secondaryBackground,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: FlutterFlowTheme.of(context).alternate,
          width: 1,
        ),
      ),
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(8, 6, 8, 6),
            child: Row(
              children: [
                Expanded(
                  child: TextField(
                    controller: _quickAddController,
                    decoration: const InputDecoration(
                      hintText: 'Quick add task…',
                      border: InputBorder.none,
                      isDense: true,
                      contentPadding: EdgeInsets.zero,
                    ),
                    onSubmitted: (_) => _submitQuickAdd(),
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.send),
                  onPressed: _submitQuickAdd,
                  padding: const EdgeInsets.all(4),
                  constraints:
                      const BoxConstraints(minWidth: 32, minHeight: 32),
                ),
              ],
            ),
          ),
          ...[
            Divider(
              height: 1,
              thickness: 1,
              color: FlutterFlowTheme.of(context).alternate,
            ),
            Padding(
              padding: const EdgeInsets.fromLTRB(8, 6, 8, 6),
              child: Column(
                children: [
                  Row(
                    children: [
                      IconTaskTypeDropdown(
                        selectedValue: _selectedQuickTrackingType ?? 'binary',
                        onChanged: (value) {
                          setState(() {
                            _selectedQuickTrackingType = value;
                            if (value == 'binary') {
                              _quickTargetNumber = 1;
                              _quickTargetDuration = const Duration(hours: 1);
                              _quickUnitController.clear();
                            }
                          });
                        },
                        tooltip: 'Select task type',
                      ),
                      const SizedBox(width: 4),
                      // Show due date button only when no date is selected
                      if (_selectedQuickDueDate == null)
                        IconButton(
                          icon: Icon(
                            Icons.calendar_today_outlined,
                            color: FlutterFlowTheme.of(context).secondaryText,
                          ),
                          onPressed: _selectQuickDueDate,
                          tooltip: 'Set due date',
                          padding: const EdgeInsets.all(4),
                          constraints:
                              const BoxConstraints(minWidth: 32, minHeight: 32),
                        ),
                      // Show due date description when date is selected
                      if (_selectedQuickDueDate != null)
                        InkWell(
                          onTap: _selectQuickDueDate,
                          borderRadius: BorderRadius.circular(6),
                          child: Container(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 8, vertical: 6),
                            decoration: BoxDecoration(
                              color: Colors.green.shade50,
                              borderRadius: BorderRadius.circular(6),
                              border: Border.all(color: Colors.green.shade200),
                            ),
                            child: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Icon(Icons.calendar_today,
                                    size: 14, color: Colors.green.shade700),
                                const SizedBox(width: 6),
                                Text(
                                  quickIsRecurring
                                      ? 'From ${DateFormat('MMM dd').format(_selectedQuickDueDate!)}'
                                      : DateFormat('MMM dd')
                                          .format(_selectedQuickDueDate!),
                                  style: TextStyle(
                                    fontSize: 11,
                                    color: Colors.green.shade700,
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                                const SizedBox(width: 6),
                                InkWell(
                                  onTap: () {
                                    // Clear due date without opening picker
                                    setState(() {
                                      _selectedQuickDueDate = null;
                                    });
                                  },
                                  child: Icon(
                                    Icons.close,
                                    size: 14,
                                    color: Colors.green.shade700,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                      // Show recurring button only when no frequency is configured
                      if (!quickIsRecurring || _quickFrequencyConfig == null)
                        IconButton(
                          icon: Icon(
                            Icons.repeat_outlined,
                            color: FlutterFlowTheme.of(context).secondaryText,
                          ),
                          onPressed: () async {
                            // Opening recurring - show frequency config
                            final config = await showFrequencyConfigDialog(
                              context: context,
                              initialConfig: _quickFrequencyConfig ??
                                  FrequencyConfig(
                                    type: FrequencyType.everyXPeriod,
                                    startDate:
                                        _selectedQuickDueDate ?? DateTime.now(),
                                  ),
                            );
                            if (config != null) {
                              setState(() {
                                _quickFrequencyConfig = config;
                                quickIsRecurring = true;
                                // Sync start date to due date
                                _selectedQuickDueDate = config.startDate;
                              });
                            }
                          },
                          tooltip: 'Make recurring',
                          padding: const EdgeInsets.all(4),
                          constraints:
                              const BoxConstraints(minWidth: 32, minHeight: 32),
                        ),
                      // Show frequency description when configured
                      if (quickIsRecurring && _quickFrequencyConfig != null)
                        InkWell(
                          onTap: () async {
                            // Reopen frequency config dialog to edit
                            final config = await showFrequencyConfigDialog(
                              context: context,
                              initialConfig: _quickFrequencyConfig,
                            );
                            if (config != null) {
                              setState(() {
                                _quickFrequencyConfig = config;
                                // Sync start date to due date
                                _selectedQuickDueDate = config.startDate;
                              });
                            }
                          },
                          borderRadius: BorderRadius.circular(6),
                          child: Container(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 8, vertical: 6),
                            decoration: BoxDecoration(
                              color: Colors.blue.shade50,
                              borderRadius: BorderRadius.circular(6),
                              border: Border.all(color: Colors.blue.shade200),
                            ),
                            child: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Icon(Icons.repeat,
                                    size: 14, color: Colors.blue.shade700),
                                const SizedBox(width: 6),
                                Text(
                                  _getQuickFrequencyDescription(),
                                  style: TextStyle(
                                    fontSize: 11,
                                    color: Colors.blue.shade700,
                                    fontWeight: FontWeight.w500,
                                  ),
                                ),
                                const SizedBox(width: 6),
                                InkWell(
                                  onTap: () {
                                    // Clear recurrence without opening dialog
                                    setState(() {
                                      quickIsRecurring = false;
                                      _quickFrequencyConfig = null;
                                    });
                                  },
                                  child: Icon(
                                    Icons.close,
                                    size: 14,
                                    color: Colors.blue.shade700,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                    ],
                  ),
                  if (_selectedQuickTrackingType == 'quantitative') ...[
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Colors.orange.shade50,
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(color: Colors.orange.shade200),
                      ),
                      child: Row(
                        children: [
                          Icon(Icons.track_changes,
                              size: 16, color: Colors.orange.shade700),
                          const SizedBox(width: 8),
                          Text(
                            'Target:',
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.orange.shade700,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: TextFormField(
                              initialValue: _quickTargetNumber.toString(),
                              decoration: InputDecoration(
                                border: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(6),
                                  borderSide:
                                      BorderSide(color: Colors.orange.shade300),
                                ),
                                enabledBorder: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(6),
                                  borderSide:
                                      BorderSide(color: Colors.orange.shade300),
                                ),
                                focusedBorder: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(6),
                                  borderSide: BorderSide(
                                      color: Colors.orange.shade500, width: 2),
                                ),
                                contentPadding: const EdgeInsets.symmetric(
                                    horizontal: 8, vertical: 6),
                                isDense: true,
                              ),
                              keyboardType: TextInputType.number,
                              onChanged: (value) {
                                _quickTargetNumber = int.tryParse(value) ?? 1;
                              },
                            ),
                          ),
                          const SizedBox(width: 8),
                          Text(
                            'Unit:',
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.orange.shade700,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: TextFormField(
                              controller: _quickUnitController,
                              decoration: InputDecoration(
                                border: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(6),
                                  borderSide:
                                      BorderSide(color: Colors.orange.shade300),
                                ),
                                enabledBorder: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(6),
                                  borderSide:
                                      BorderSide(color: Colors.orange.shade300),
                                ),
                                focusedBorder: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(6),
                                  borderSide: BorderSide(
                                      color: Colors.orange.shade500, width: 2),
                                ),
                                contentPadding: const EdgeInsets.symmetric(
                                    horizontal: 8, vertical: 6),
                                hintText: 'e.g., pages, reps',
                                isDense: true,
                              ),
                              onChanged: (value) {},
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 8),
                  ],
                  if (_selectedQuickTrackingType == 'time') ...[
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Colors.purple.shade50,
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(color: Colors.purple.shade200),
                      ),
                      child: Row(
                        children: [
                          Icon(Icons.timer,
                              size: 16, color: Colors.purple.shade700),
                          const SizedBox(width: 8),
                          Text(
                            'Target Duration:',
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.purple.shade700,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: TextFormField(
                              initialValue:
                                  _quickTargetDuration.inHours.toString(),
                              decoration: InputDecoration(
                                border: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(6),
                                  borderSide:
                                      BorderSide(color: Colors.purple.shade300),
                                ),
                                enabledBorder: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(6),
                                  borderSide:
                                      BorderSide(color: Colors.purple.shade300),
                                ),
                                focusedBorder: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(6),
                                  borderSide: BorderSide(
                                      color: Colors.purple.shade500, width: 2),
                                ),
                                contentPadding: const EdgeInsets.symmetric(
                                    horizontal: 8, vertical: 6),
                                labelText: 'Hours',
                                isDense: true,
                              ),
                              keyboardType: TextInputType.number,
                              onChanged: (value) {
                                final hours = int.tryParse(value) ?? 1;
                                _quickTargetDuration = Duration(
                                  hours: hours,
                                  minutes: _quickTargetDuration.inMinutes % 60,
                                );
                              },
                            ),
                          ),
                          const SizedBox(width: 4),
                          Expanded(
                            child: TextFormField(
                              initialValue:
                                  (_quickTargetDuration.inMinutes % 60)
                                      .toString(),
                              decoration: InputDecoration(
                                border: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(6),
                                  borderSide:
                                      BorderSide(color: Colors.purple.shade300),
                                ),
                                enabledBorder: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(6),
                                  borderSide:
                                      BorderSide(color: Colors.purple.shade300),
                                ),
                                focusedBorder: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(6),
                                  borderSide: BorderSide(
                                      color: Colors.purple.shade500, width: 2),
                                ),
                                contentPadding: const EdgeInsets.symmetric(
                                    horizontal: 8, vertical: 6),
                                labelText: 'Minutes',
                                isDense: true,
                              ),
                              keyboardType: TextInputType.number,
                              onChanged: (value) {
                                final minutes = int.tryParse(value) ?? 0;
                                _quickTargetDuration = Duration(
                                  hours: _quickTargetDuration.inHours,
                                  minutes: minutes,
                                );
                              },
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 8),
                  ],
                ],
              ),
            ),
          ],
        ],
      ),
    );
    return quickAddWidget;
  }

  bool _isTaskCompleted(ActivityRecord task) {
    if (!task.isActive) return false;
    switch (task.trackingType) {
      case 'binary':
        return task.status == 'complete';
      case 'quantitative':
        final currentValue = task.currentValue ?? 0;
        final target = task.target ?? 0;
        return target > 0 && currentValue >= target;
      case 'time':
        final currentMinutes = (task.accumulatedTime) ~/ 60000;
        final targetMinutes = task.target ?? 0;
        return targetMinutes > 0 && currentMinutes >= targetMinutes;
      default:
        return task.status == 'complete';
    }
  }

  String _getQuickFrequencyDescription() {
    if (_quickFrequencyConfig == null) return '';

    switch (_quickFrequencyConfig!.type) {
      case FrequencyType.specificDays:
        const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
        final selectedDayNames = _quickFrequencyConfig!.selectedDays
            .map((day) => days[day - 1])
            .join(', ');
        return 'Recurring on $selectedDayNames';
      case FrequencyType.timesPerPeriod:
        final String period;
        switch (_quickFrequencyConfig!.periodType) {
          case PeriodType.weeks:
            period = 'week';
            break;
          case PeriodType.months:
            period = 'month';
            break;
          case PeriodType.year:
            period = 'year';
            break;
          case PeriodType.days:
            period = 'days';
            break;
        }
        return 'Recurring ${_quickFrequencyConfig!.timesPerPeriod} times per $period';
      case FrequencyType.everyXPeriod:
        // Special case: every 1 day is the same as every day
        if (_quickFrequencyConfig!.everyXValue == 1 &&
            _quickFrequencyConfig!.everyXPeriodType == PeriodType.days) {
          return 'Recurring every day';
        }
        final String period;
        switch (_quickFrequencyConfig!.everyXPeriodType) {
          case PeriodType.days:
            period = 'days';
            break;
          case PeriodType.weeks:
            period = 'weeks';
            break;
          case PeriodType.months:
            period = 'months';
            break;
          case PeriodType.year:
            period = 'years';
            break;
        }
        return 'Recurring every ${_quickFrequencyConfig!.everyXValue} $period';
      default:
        return 'Recurring';
    }
  }

  List<Widget> _buildSections() {
    final theme = FlutterFlowTheme.of(context);
    final buckets = _bucketedItems;
    final order = [
      'Overdue',
      'Today',
      'Tomorrow',
      'This Week',
      'Later',
      'No due date'
    ];
    final widgets = <Widget>[];
    for (final key in order) {
      final items = List<dynamic>.from(buckets[key]!);
      final visibleItems = items.where((item) {
        if (item is ActivityRecord) {
          final isCompleted = _isTaskCompleted(item);
          return _showCompleted || !isCompleted;
        }
        return true;
      }).toList();
      if (visibleItems.isEmpty) continue;
      _applySort(visibleItems);
      final isExpanded = _sectionExpanded[key] ?? true;
      widgets.add(
        SliverToBoxAdapter(
          child: _buildSectionHeader(key, visibleItems.length, isExpanded),
        ),
      );
      if (isExpanded) {
        widgets.add(
          SliverList(
            delegate: SliverChildBuilderDelegate(
              (context, index) {
                final item = visibleItems[index];
                return _buildItemTile(item, key);
              },
              childCount: visibleItems.length,
            ),
          ),
        );
        widgets.add(
          const SliverToBoxAdapter(
            child: SizedBox(height: 8),
          ),
        );
      }
    }
    if (widgets.isEmpty) {
      widgets.add(SliverFillRemaining(
        child: Padding(
          padding: const EdgeInsets.only(top: 80),
          child: Center(
            child: Text(
              'No tasks yet',
              style: theme.bodyLarge,
            ),
          ),
        ),
      ));
    }
    return widgets;
  }

  Widget _buildSectionHeader(String title, int count, bool isExpanded) {
    final theme = FlutterFlowTheme.of(context);
    return Container(
      margin: EdgeInsets.fromLTRB(16, 8, 16, isExpanded ? 0 : 6),
      padding: EdgeInsets.fromLTRB(12, 8, 12, isExpanded ? 2 : 6),
      decoration: BoxDecoration(
        gradient: theme.neumorphicGradient,
        border: Border.all(
          color: theme.surfaceBorderColor,
          width: 1,
        ),
        borderRadius: BorderRadius.only(
          topLeft: const Radius.circular(16),
          topRight: const Radius.circular(16),
          bottomLeft: isExpanded ? Radius.zero : const Radius.circular(16),
          bottomRight: isExpanded ? Radius.zero : const Radius.circular(16),
        ),
        boxShadow: isExpanded ? [] : theme.neumorphicShadowsRaised,
      ),
      child: InkWell(
        onTap: () {
          setState(() {
            _sectionExpanded[title] = !isExpanded;
          });
        },
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              '$title ($count)',
              style: theme.titleMedium.override(
                fontFamily: 'Readex Pro',
                fontWeight: FontWeight.w600,
              ),
            ),
            Icon(
              isExpanded ? Icons.expand_less : Icons.expand_more,
              size: 28,
            ),
          ],
        ),
      ),
    );
  }

  String _getSubtitle(ActivityRecord task, String bucketKey) {
    if (bucketKey == 'Today' || bucketKey == 'Tomorrow') {
      return task.categoryName;
    }
    final dueDate = task.dueDate;
    if (dueDate != null) {
      final formattedDate = DateFormat.MMMd().format(dueDate);
      if (task.categoryName.isNotEmpty) {
        return '$formattedDate • ${task.categoryName}';
      }
      return formattedDate;
    }
    return task.categoryName;
  }

  Future<void> _submitQuickAdd() async {
    final title = _quickAddController.text.trim();
    if (title.isEmpty) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please enter a task name')),
      );
      return;
    }

    final categoryId = widget.categoryId;
    if (categoryId == null) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Category not found for this tab')),
      );
      return;
    }

    if (_selectedQuickTrackingType == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a tracking type')),
      );
      return;
    }

    print('--- task_page.dart: Starting _submitQuickAdd...');
    try {
      dynamic targetValue;
      switch (_selectedQuickTrackingType) {
        case 'binary':
          targetValue = null;
          break;
        case 'quantitative':
          targetValue = _quickTargetNumber;
          break;
        case 'time':
          targetValue = _quickTargetDuration.inMinutes;
          break;
        default:
          targetValue = null;
      }
      print(
          '--- task_page.dart: Target value determined: $targetValue for type $_selectedQuickTrackingType');

      // Convert frequency config to schedule and frequency fields
      if (quickIsRecurring && _quickFrequencyConfig != null) {
        print(
            '--- task_page.dart: Handling recurring task with config: $_quickFrequencyConfig');
        // The following fields are deprecated but we keep the logic here
        // in case we need to roll back to a previous data model.
        // String? schedule;
        // int? frequency;
        // List<int>? specificDays;
        //
        // switch (_quickFrequencyConfig!.type) {
        //   case FrequencyType.daily:
        //     schedule = 'daily';
        //     frequency = 1;
        //     break;
        //   case FrequencyType.specificDays:
        //     schedule = 'weekly';
        //     frequency = _quickFrequencyConfig!.selectedDays.length;
        //     specificDays = _quickFrequencyConfig!.selectedDays;
        //     break;
        //   case FrequencyType.timesPerPeriod:
        //     schedule = _quickFrequencyConfig!.periodType == PeriodType.weeks
        //         ? 'weekly'
        //         : _quickFrequencyConfig!.periodType == PeriodType.months
        //             ? 'monthly'
        //             : 'yearly';
        //     frequency = _quickFrequencyConfig!.timesPerPeriod;
        //     break;
        //   case FrequencyType.everyXPeriod:
        //     schedule =
        //         _quickFrequencyConfig!.everyXPeriodType == PeriodType.days
        //             ? 'daily'
        //             : _quickFrequencyConfig!.everyXPeriodType ==
        //                     PeriodType.weeks
        //                 ? 'weekly'
        //                 : 'monthly';
        //     frequency = _quickFrequencyConfig!.everyXValue;
        //     break;
        // }
      }

      print('--- task_page.dart: Preparing to create ActivityRecord data...');
      final taskData = createActivityRecordData(
        showInFloatingTimer: true,
        name: title,
        categoryId: categoryId,
        categoryName:
            _categories.firstWhere((c) => c.reference.id == categoryId).name,
        trackingType: _selectedQuickTrackingType!,
        target: targetValue,
        status: 'incomplete',
        isRecurring: quickIsRecurring,
        isActive: true,
        createdTime: DateTime.now(),
        lastUpdated: DateTime.now(),
        userId: currentUserUid,
        dueDate: _selectedQuickDueDate,
        priority: 1,
        unit: _quickUnit,
        schedule: null, // Deprecated
        frequency: null, // Deprecated
        specificDays: _quickFrequencyConfig != null &&
                _quickFrequencyConfig!.type == FrequencyType.specificDays
            ? _quickFrequencyConfig!.selectedDays
            : null,
        categoryType: 'task',
        startDate: quickIsRecurring
            ? _quickFrequencyConfig!.startDate
            : DateTime.now(),
        endDate: quickIsRecurring ? _quickFrequencyConfig!.endDate : null,

        // New frequency fields - only store relevant fields based on frequency type
        frequencyType: quickIsRecurring
            ? _quickFrequencyConfig!.type.toString().split('.').last
            : null,
        // Only store everyX fields if frequency type is everyXPeriod
        everyXValue: quickIsRecurring &&
                _quickFrequencyConfig!.type == FrequencyType.everyXPeriod
            ? _quickFrequencyConfig!.everyXValue
            : null,
        everyXPeriodType: quickIsRecurring &&
                _quickFrequencyConfig!.type == FrequencyType.everyXPeriod
            ? _quickFrequencyConfig!.everyXPeriodType.toString().split('.').last
            : null,
        // Only store timesPerPeriod fields if frequency type is timesPerPeriod
        timesPerPeriod: quickIsRecurring &&
                _quickFrequencyConfig!.type == FrequencyType.timesPerPeriod
            ? _quickFrequencyConfig!.timesPerPeriod
            : null,
        periodType: quickIsRecurring &&
                _quickFrequencyConfig!.type == FrequencyType.timesPerPeriod
            ? _quickFrequencyConfig!.periodType.toString().split('.').last
            : null,
      );
      print('--- task_page.dart: ActivityRecord data created: $taskData');

      final docRef =
          await ActivityRecord.collectionForUser(currentUserUid).add(taskData);
      print(
          '--- task_page.dart: ActivityRecord added to Firestore with ID: ${docRef.id}');

      final newTask = ActivityRecord.getDocumentFromData(taskData, docRef);
      print('--- task_page.dart: New task object created: ${newTask.name}');

      setState(() {
        print(
            '--- task_page.dart: setState called to add new task and clear inputs.');
        _tasks.add(newTask);
        _quickAddController.clear();
        _selectedQuickTrackingType = 'binary'; // Reset to default task type
        _quickTargetNumber = 1;
        _quickTargetDuration = const Duration(hours: 1);
        _quickUnit = '';
        _quickUnitController.clear();
        _selectedQuickDueDate = null;
        _quickFrequencyConfig = null;
        quickIsRecurring = false;
      });
      print('--- task_page.dart: _submitQuickAdd completed successfully.');
    } catch (e) {
      print('--- task_page.dart: ERROR in _submitQuickAdd: $e');
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error adding task: $e')),
      );
    }
  }

  Future<void> _selectQuickDueDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedQuickDueDate ?? DateTime.now(),
      firstDate: DateTime.now().subtract(const Duration(days: 365)),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );
    if (picked != null && picked != _selectedQuickDueDate) {
      setState(() {
        _selectedQuickDueDate = picked;
        // Sync to frequency config if recurring
        if (quickIsRecurring && _quickFrequencyConfig != null) {
          _quickFrequencyConfig =
              _quickFrequencyConfig!.copyWith(startDate: picked);
        }
      });
    }
  }

  Map<String, List<dynamic>> get _bucketedItems {
    final Map<String, List<dynamic>> buckets = {
      'Overdue': [],
      'Today': [],
      'Tomorrow': [],
      'This Week': [],
      'Later': [],
      'No due date': [],
    };

    final today = _todayDate();
    final startOfWeek = today.subtract(Duration(days: today.weekday - 1));
    final endOfWeek = startOfWeek.add(const Duration(days: 6));

    void addToBucket(ActivityRecord h, DateTime? dueDate) {
      if (!_showCompleted && _isTaskCompleted(h)) return;

      if (dueDate == null) {
        buckets['No due date']!.add(h);
        return;
      }

      if (dueDate.isBefore(today)) {
        buckets['Overdue']!.add(h);
      } else if (_isSameDay(dueDate, today)) {
        buckets['Today']!.add(h);
      } else if (_isSameDay(dueDate, _tomorrowDate())) {
        buckets['Tomorrow']!.add(h);
      } else if (!dueDate.isAfter(endOfWeek)) {
        buckets['This Week']!.add(h);
      } else {
        buckets['Later']!.add(h);
      }
    }

    for (final t in _tasks) {
      if (!t.isActive) continue;
      if (widget.categoryId != null && t.categoryId != widget.categoryId)
        continue;
      addToBucket(t, t.dueDate);
    }
    for (final h in _habits) {
      if (!h.isActive) continue;
      if (widget.categoryId != null && h.categoryId != widget.categoryId)
        continue;

      if (HabitTrackingUtil.shouldTrackToday(h)) {
        addToBucket(h, today);
      } else {
        final next = _nextDueDateForHabit(h, today);
        addToBucket(h, next);
      }
    }

    return buckets;
  }

  Widget _buildItemTile(dynamic item, String bucketKey) {
    if (item is ActivityRecord) {
      return _buildTaskTile(item, bucketKey);
    }
    return const SizedBox.shrink();
  }

  void _applySort(List<dynamic> items) {
    if (sortMode != 'importance') return;
    int cmpTask(ActivityRecord a, ActivityRecord b) {
      final ap = a.priority;
      final bp = b.priority;
      if (bp != ap) return bp.compareTo(ap);
      final ad = a.dueDate;
      final bd = b.dueDate;
      if (ad != null && bd != null) return ad.compareTo(bd);
      if (ad != null) return -1;
      if (bd != null) return 1;
      return a.name.toLowerCase().compareTo(b.name.toLowerCase());
    }

    items.sort((x, y) {
      final xt = x is ActivityRecord;
      final yt = y is ActivityRecord;
      if (xt && yt) return cmpTask(x, y);
      if (xt && !yt) return -1;
      if (!xt && yt) return 1;
      return 0;
    });
  }

  DateTime _todayDate() {
    final now = DateTime.now();
    return DateTime(now.year, now.month, now.day);
  }

  bool _isSameDay(DateTime a, DateTime b) =>
      a.year == b.year && a.month == b.month && a.day == b.day;

  DateTime _tomorrowDate() => _todayDate().add(const Duration(days: 1));

  DateTime? _nextDueDateForHabit(ActivityRecord h, DateTime today) {
    switch (h.schedule) {
      case 'daily':
        return today;
      case 'weekly':
        if (h.specificDays.isNotEmpty) {
          for (int i = 0; i < 7; i++) {
            final candidate = today.add(Duration(days: i));
            if (h.specificDays.contains(candidate.weekday)) return candidate;
          }
          return today.add(const Duration(days: 7));
        }
        return today;
      case 'monthly':
        return today.add(const Duration(days: 3));
      default:
        return today.add(const Duration(days: 1));
    }
  }

  Widget _buildTaskTile(ActivityRecord task, String bucketKey) {
    return ItemComponent(
      page: "task",
      subtitle: _getSubtitle(task, bucketKey),
      showCalendar: true,
      showTaskEdit: true,
      key: Key(task.reference.id),
      habit: task,
      showCompleted: _showCompleted,
      categories: _categories,
      tasks: _tasks,
      onRefresh: _loadData,
      onHabitUpdated: (updated) => _updateHabitInLocalState(updated),
      onHabitDeleted: (deleted) async => _loadData(),
      showTypeIcon: false,
      showRecurringIcon: true,
    );
  }

  void _updateHabitInLocalState(ActivityRecord updatedHabit) {
    setState(() {
      final habitIndex = _habits
          .indexWhere((h) => h.reference.id == updatedHabit.reference.id);
      if (habitIndex != -1) {
        _habits[habitIndex] = updatedHabit;
      }
      final taskIndex =
          _tasks.indexWhere((h) => h.reference.id == updatedHabit.reference.id);
      if (taskIndex != -1) {
        _tasks[taskIndex] = updatedHabit;
      }
      if (!_showCompleted && _isTaskCompleted(updatedHabit)) {
        _tasks.removeWhere((h) => h.reference.id == updatedHabit.reference.id);
        _habits.removeWhere((h) => h.reference.id == updatedHabit.reference.id);
      }
      _loadDataSilently();
    });
  }

  Future<void> _loadDataSilently() async {
    try {
      final uid = currentUserUid;
      if (uid.isEmpty) return;
      final allHabits = await queryActivitiesRecordOnce(userId: uid);
      final categories = await queryTaskCategoriesOnce(userId: uid);
      if (!mounted) return;
      setState(() {
        _tasks = allHabits.where((h) {
          return h.categoryType == 'task';
        }).toList();
        _habits = allHabits.where((h) {
          return h.categoryType == 'habit';
        }).toList();
        _categories = categories;
        if (_selectedQuickCategoryId == null && categories.isNotEmpty) {
          _selectedQuickCategoryId = categories.first.reference.id;
        }
      });
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error loading tasks: $e')),
        );
      }
    }
  }
}